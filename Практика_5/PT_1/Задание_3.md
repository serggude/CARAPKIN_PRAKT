```python
def real_time_signal_processing(signal, coefficients):
    n = len(signal)
    filtered_signal = [0] * n
    M = len(coefficients)

    for i in range(M, n):
        for j in range(M):
            filtered_signal[i] += signal[i - j] * coefficients[j]
    return filtered_signal
````


## 1) Анализ внешнего цикла (по `i`): есть ли зависимости между итерациями?

### Что читает и что пишет итерация `i`

Для фиксированного `i` во внутреннем цикле:

* **читает**: `signal[i-j]` (разные элементы входного сигнала), `coefficients[j]`
* **пишет**: только `filtered_signal[i]` (одна ячейка результата)

### Проверка межитерационных зависимостей

* Итерация `i` записывает **только** `filtered_signal[i]`
* Итерация `i+1` записывает **только** `filtered_signal[i+1]`
* чтения идут из `signal[...]` и `coefficients[...]`, которые **не изменяются** внутри алгоритма

**Вывод:** между итерациями внешнего цикла **нет** зависимостей (нет FLOW/ANTI/OUTPUT между разными `i`).
Значит внешний цикл по `i` — хороший кандидат для распараллеливания (итерации независимы).

**Расстояние зависимости:** межитерационных зависимостей нет → расстояние не определяется (условно можно считать, что зависимости отсутствуют).


## 2) Анализ внутреннего цикла (по `j`): можно ли распараллелить?

Рассмотрим фиксированное `i`. Внутренний цикл делает:

```python
filtered_signal[i] += signal[i - j] * coefficients[j]
```

### Что происходит с данными

* На каждой итерации `j` вычисляется независимый вклад `signal[i-j] * coefficients[j]`
* Но все итерации **обновляют одну и ту же переменную** `filtered_signal[i]` через `+=`

### Какие зависимости возникают

Это типичная проблема **накопления (reduction)**:

* есть конфликт по записи в `filtered_signal[i]` (по сути серия операций read-modify-write над одной ячейкой)

**Вывод:** внутренний цикл в текущем виде **нельзя** безопасно распараллелить «в лоб», потому что все потоки будут одновременно писать в `filtered_signal[i]`.

Однако его можно распараллелить через технику **reduction**:

* каждый поток считает частичную сумму на своём диапазоне `j`
* затем частичные суммы складываются в конце (одна финальная запись в `filtered_signal[i]`)


## 3) «Бутылочное горлышко» для параллелизации

Главное узкое место — **внутренний цикл по `j`**, потому что:

* он выполняется `M` раз для каждого `i` (основная вычислительная нагрузка — именно там),
* и он содержит накопление `+=` в одну ячейку результата, что мешает прямому распараллеливанию.

Внешний цикл по `i` распараллеливается проще, но при больших `M` производительность всё равно в основном определяется количеством операций во внутреннем цикле.


## 4) Идея модификации для ускорения на многопроцессорной системе

### Вариант 1: распараллелить внешний цикл по `i`

Каждая итерация `i` независима → можно делать `parallel for` по `i`:

* разные потоки вычисляют разные `filtered_signal[i]`

Схематично:

```python
for i in parallel_range(M, n):
    acc = 0
    for j in range(M):
        acc += signal[i-j] * coefficients[j]
    filtered_signal[i] = acc
```

### Вариант 2: распараллелить внутренний цикл через reduction

Для фиксированного `i`:

* разбить диапазон `j` на блоки
* посчитать частичные суммы параллельно
* сложить их в конце

Схематично:

```python
for i in range(M, n):
    partial_sums = parallel_map( chunks(j=0..M-1), lambda chunk: sum(signal[i-j]*coeff[j] for j in chunk) )
    filtered_signal[i] = sum(partial_sums)
```

### Вариант 3 (часто лучший на практике): векторизация / FFT-свёртка

Если `M` большой и сигнал длинный, можно заменить прямую свёртку на FFT-свёртку (концептуально):

* вычислять свёртку быстрее асимптотически
* хорошо ложится на оптимизированные библиотеки


## Итоговый вывод

* Внешний цикл по `i` **не содержит межитерационных зависимостей** и хорошо распараллеливается.
* Внутренний цикл по `j` в исходном виде **упирается в накопление** `filtered_signal[i] += ...`, поэтому прямой параллелизм невозможен без преобразования.
* Основное «бутылочное горлышко» — **внутренний цикл** (основной объём вычислений и конфликт записи).
* Для ускорения на многопроцессорной системе подходят идеи:

  1. параллелизм по `i`,
  2. reduction по `j`,
  3. (при больших размерах) замена на FFT-свёртку / векторизацию.

