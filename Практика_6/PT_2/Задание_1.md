### Исходный код

```python
def diagonal_dependency(n, m):
    a = np.zeros((n, m))
    for i in range(1, n):
        for j in range(1, m):
            a[i][j] = a[i-1][j-1] + 1
    return a
````

## 1. Анализ обращений к памяти

На каждой итерации цикла с индексами `(i, j)`:

* **Чтение:** `a[i-1][j-1]`
* **Запись:** `a[i][j]`

Читается и записывается **один и тот же массив `a`**, но с разными индексами.

## 2. Поиск зависимостей (источник → сток)

Рассмотрим зависимость для массива `a`:

* **Источник (запись):**
  `k = (i-1, j-1)`
* **Сток (чтение):**
  `λ = (i, j)`

Это ситуация, когда значение, вычисленное на предыдущей итерации, используется на следующей.

## 3. Вектор расстояний и вектор направлений

Вектор расстояний:

```
D = λ − k = (i − (i−1), j − (j−1)) = (1, 1)
```

Вектор направлений:

```
d = ("<", "<")
```

Тип зависимости:

* **Flow-зависимость (истинная зависимость)**

## 4. Граф зависимостей

Каждый элемент `a[i][j]` зависит от элемента, расположенного **по диагонали сверху слева**:


## 5. Возможность распараллеливания

* Внешний цикл `i` **нельзя** распараллелить напрямую
* Внутренний цикл `j` **нельзя** распараллелить напрямую

Причина:
каждая итерация `(i, j)` зависит от результата `(i-1, j-1)`.

**Прямая параллелизация запрещена** из-за диагональной зависимости.


## 6. Альтернативный алгоритм без диагональной зависимости

### Идея: волновой (diagonal / wavefront) алгоритм

Элементы, лежащие на одной диагонали `i + j = const`, **не зависят друг от друга** и могут вычисляться параллельно.

### Переписанный алгоритм (волновой фронт)

```python
for s in range(2, n + m):
    for i in range(1, n):
        j = s - i
        if 1 <= j < m:
            a[i][j] = a[i-1][j-1] + 1
```


## 7. Вывод

* Исходный алгоритм содержит **диагональную Flow-зависимость**
* Прямая параллелизация невозможна
* После преобразования к **волновому алгоритму** появляется параллелизм
* Параллельное выполнение возможно **внутри одной диагонали**

