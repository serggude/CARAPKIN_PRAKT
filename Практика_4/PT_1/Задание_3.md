
## 1. Исходный алгоритм

```python
def real_world_algorithm(data):
    n = len(data)
    result = [0] * n
    for i in range(1, n):
        result[i] = (data[i-1] + data[i] + data[i+1]) / 3
    return result
```

## 2. Развертка цикла для n=5

Входной массив имеет вид :

```python
data = [d0, d1, d2, d3, d4]
```
Тогда выполнение цикла эквивалентно следующим операциям:

* итерация i=1
```python
result[1] = (data[0] + data[1] + data[2]) / 3
```
* итерация i=2
```python
result[2] = (data[1] + data[2] + data[3]) / 3
```
* итерация i=3
```python
result[3] = (data[2] + data[3] + data[4]) / 3
```

## 3. Анализ операций чтения и записи 

Для каждой итерации цикла определим, какие элементы читаются и какие записываются.

| Итерация | Читаемые данные           | Записываемые данные |
| -------- | ------------------------- | ------------------- |
| i = 1    | data[0], data[1], data[2] | result[1]           |
| i = 2    | data[1], data[2], data[3] | result[2]           |
| i = 3    | data[2], data[3], data[4] | result[3]           |

## 4. Анализ зависмостей между итерациями 
В ходе анализа установлено:
* массив data только читается и не изменяется;
* каждая итерация цикла записывает результат в собственную уникальную ячейку массива result;
* отсутствуют:
  * Flow-зависимости (Read After Write),
  * Anti-зависимости (Write After Read),
  * Output-зависимости (Write After Write).
* Следовательно, между итерациями цикла отсутствуют зависимости.

## 5. Граф завсимостей 

## 6. Возможность распараллеливания 
Так как каждая итерация цикла использует только исходные данные, не изменяет данные, используемые другими итерациями и записывает результат в уникальный элемент массива, то данный цикл может быть распараллелен по данным.