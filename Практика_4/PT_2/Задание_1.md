```python
def homework_basic(data_sequence):
    '''
    Базовое задание: устраните зависимости в этом алгоритме
    обработки временных рядов
    '''
    result = []
    current = data_sequence[0]
    for i in range(1, len(data_sequence)):
        # ⚠️ Найдите и устраните все зависимости
        current = current * 0.9 + data_sequence[i] * 0.1
        result.append(current)
    return result
```

### **Анализ исходного алгоритма**

#### **Структура вычислений**

Внутри цикла выполняется операция:

```
current = 0.9 * current + 0.1 * data_sequence[i]
```

Это представляет собой рекуррентную зависимость:

```
current[i] = 0.9 * current[i–1] + 0.1 * data[i]
```

#### **Тип обнаруженной зависимости**

| Переменная | Где читается                | Где пишется                     | Тип зависимости |
| ---------- | --------------------------- | ------------------------------- | --------------- |
| `current`  | читается в текущей итерации | записывается в текущей итерации | **Flow (RAW)**  |

**Flow-зависимость (Read After Write)** означает, что каждая следующая итерация зависит от результата предыдущей, что делает параллельное исполнение невозможным.

Это подтверждается материалом презентации (методы устранения зависимостей на стр. 17):
flow-зависимости — самые тяжёлые, устраняются через **сдваивание (double buffering)** или **математическое развертывание формулы**.

### **Принцип устранения зависимости**

Так как рекуррентная формула является линейной (экспоненциальное сглаживание), её можно развернуть в независимую сумму:

```
current[i] = 0.9^i * data[0] +
             0.9^(i–1) * 0.1 * data[1] +
             ...
             0.9^0 * 0.1 * data[i]
```

Теперь вычисление значения `current[i]` не зависит от результата предыдущих итераций, а зависит только от **исходной последовательности**, которую менять мы не собираемся.

Таким образом, мы устраняем flow-зависимость, переводя задачу в чисто параллельную форму.

Метод соответствует:

* **Метод 3: Сдваивание (Double Buffering)** — по смыслу мы отделяем данные чтения от данных записи.
* **Разрыв рекурсии через математическую развёртку** — официальный способ устранения flow-зависимостей для линейных фильтров.

### **Оптимизированная версия алгоритма (без зависимостей)**

```python
def homework_basic_solution(data_sequence):
    n = len(data_sequence)
    result = [0] * n

    alpha = 0.1
    beta = 0.9

    # Предвычисляем степени beta
    beta_powers = [beta ** k for k in range(n)]

    # Развёрнутая формула экспоненциального сглаживания
    for i in range(n):
        total = 0
        for j in range(i + 1):
            if j == 0:
                total += data_sequence[0] * beta_powers[i]
            else:
                total += data_sequence[j] * alpha * beta_powers[i - j]
        result[i] = total

    return result
```

* каждая итерация цикла по `i` **полностью независима**;
* можно распараллелить по 8–64 потокам;
* функция использует только исходные данные — **открывает возможность параллельной обработки временного ряда**.

### **Методы, использованные для устранения зависимостей**

#### **Метод: Сдваивание (Double Buffering)**

Идея:

* данные для чтения — отдельный буфер;
* данные для записи — отдельный буфер;
* в итоге не происходит чтения и записи в одну и ту же переменную.

В нашем случае:

* исходная последовательность `data_sequence` — «старый буфер»;
* выходной массив `result` — «новый буфер»;
* значение `current[i]` вычисляется напрямую, без использования предыдущего `current[i-1]`.

#### **Математическая развёртка рекурсии**

* разрыв flow-зависимости путём переписывания рекуррентной формулы в явном виде;
* превращает последовательный фильтр в независимые элементы.

### **вывод**

* Исходный алгоритм содержит **жёсткую flow-зависимость** по переменной `current`.
* Эта зависимость **полностью предотвращает параллелизацию**.
* С помощью **развёртки рекуррентной формулы** и **принципа double buffering** зависимость была устранена.
* Итерации стали независимыми, что соответствует требованиям задачи и рекомендациям презентации (стр. 17).

В результате получен алгоритм, подходящий для распараллеливания и соответствующий методикам устранения зависимостей, приведённым в практической работе.
