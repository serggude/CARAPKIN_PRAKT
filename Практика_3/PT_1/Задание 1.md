Исходный фрагмент программы :

```python
for i in range(3, 7):
    y[i] = y[i-3] + z[i]
```

Цикл выполняется для `i = 3, 4, 5, 6`

### **1. Развёртка цикла**

Нужно расписать цикл по шагам:

**i = 3**
  `y[3] = y[0] + z[3]`

**i = 4**
  `y[4] = y[1] + z[4]`

**i = 5**
  `y[5] = y[2] + z[5]`

**i = 6**
  `y[6] = y[3] + z[6]`

### **2. Анализ зависимостей**

Нужно найти значения которые используют вычилсения из предыдущего шага

* `6` читает `y[3]`, который вычисляется в `O3`

Значит:

```
O3 → O6   (истинная зависимость)
```

Остальные операции независимы друг от друга:

* `O3` не зависит от `O4`, `O5`
* `O4` не зависит от `O3`, `O5`, `O6`
* `O5` не зависит от `O3`, `O4`, `O6`


### **3. Граф зависимостей**

```
O3 -----> O6
O4
O5
```

Вертикальный вид:

```
O3 → O6
O4
O5
```

### **4. Ярусно-параллельная форма (ЯПФ)**

**Ярус 1** — операции без входящих зависимостей:

```
[ O3, O4, O5 ]
```

**Ярус 2** — операции, зависящие от яруса 1:

```
[ O6 ]
```

**Высота ЯПФ: 2**

---

### **5. Вывод о параллелизуемости**

Цикл можно распараллелить, потому что зависимость имеет длинный шаг `i − 3`:

* операции **O3, O4, O5** независимы → можно выполнять параллельно;
* операция **O6** зависит только от результата **O3** → выполняется после яруса 1.

Таким образом:

* цикл **не является полностью последовательным**,
* он имеет **параллелизм шириной 3**,
* и требует **2 яруса** для корректного выполнения.
